let {firstName}  = require( './Module/profile');
/**
 * 严格模式：
 * （1）ES6 的模块自动采用严格模式，不管你有没有在模块头部加上"use strict";。
 * （2）严格模式主要有以下限制：
 *      --变量必须声明后再使用
 *      --函数的参数不能有同名属性，否则报错
 *      --不能使用with语句
 *      --不能对只读属性赋值，否则报错
 *      --不能使用前缀 0 表示八进制数，否则报错
 *      --不能删除不可删除的属性，否则报错
 *      --不能删除变量delete prop，会报错，只能删除属性delete global[prop]
 *      --eval不会在它的外层作用域引入变量
 *      --eval和arguments不能被重新赋值
 *      --arguments不会自动反映函数参数的变化
 *      --不能使用arguments.callee
 *      --不能使用arguments.caller
 *      --禁止this指向全局对象
 *      --不能使用fn.caller和fn.arguments获取函数调用的堆栈
 *      --增加了保留字（比如protected、static和interface）
 * （3）其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。
 */

/**
 * export 命令：
 * （1）模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。
 * （2）一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，
 * 就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。
 * （3）通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。重命名后，v1可以用不同的名字输出两次。
 * （4）需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系，不要直接导出模块内的变量，
 * 必须形成接口{}（对象的形式导出），且export位置必须咋js的顶层，任何{}包裹都会报错，同样的，function和class的输出，也必须遵守这样的写法。
 * （5）export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。
 * （6）export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。
 * 这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。
 */
{
  // export导出模块内接口的三种写法
  {
    // 写法一
    // export var m = 1;

    // 写法二
    // var m2 = 1;
    // export {m2}

    // 写法三
    //   var n = 1;
      // export {n as m3};
  }
  // export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。
  {
    // export var foo = 'bar';
    // setTimeout(() => foo = 'baz', 500);
    console.log(firstName);
  }
}

